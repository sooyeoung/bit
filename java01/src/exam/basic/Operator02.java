package exam.basic;

//////////////////////////////////////////////////////
//주제 : 형변환
//////////////////////////////////////////////////////
//
//만든이 :		엄진영

/* 형변환 (Type Conversion)
 * - 연산은 같은 Data 형 끼리만 가능하다. 
 *   즉, int는 int끼리, float은 float 끼리, boolean은 boolean끼리만 가능하다.
 * - 연산의 결과는 당연히 연산한 값과 같은 데이터 형이 된다.
 *   즉, int 와 int의 연산 결과값은 int가 된다.
 * - 서로 다른 Data 형 끼리의 연산시, 연산이 가능하도록 Data 형을 서로 같게 변환시켜
 *	 줘야한다. 이것을 "형변환"이라 한다.
 *
 * 형변환의 종류
 * 1)암시적 형변환(implicit type conversion)
 * - 연산시 자동으로 형변환이 이루어 지는 것을 말한다.
 * - 암시적인 형변환의 법칙
 *	 byte 
 *	short > int > long > float > double
 *	 char
 * 2)명시적 형변환(explicit type conversion)
 * - 프로그래머에 의해서 형변환이 이루어지는 것을 말함
 * - Cast Operator 를 사용하여 명시적 형변환을 한다.
 *		(데이터형)식;
 *
 * - 예1) float --> int 형으로 변환
 *		float 변수1 = 10.123f;
 *		int 변수2 = (int)변수1;
 * - 예2) long --> byte 형으로 변환
 *		byte b = (byte)1200L;
 *	 예2)의 경우 물론 컴파일시에 문제도 없고, 실행시에도 문제가 없다. 
 *   그러나, 1200 이란 수를 1 byte 메모리에 넣을 수 있을까?
 *   흠.. 없다. 강제로 꾸겨 넣어봐야... 값이 짤릴 뿐이다.
 *   큰값을 작은 메모리에 넣기위한 형변환의 사용은 잘못된 사용이다.
 *   분명히 형변환을 해서 값을 넣어도 원하는 값이 들어 간다는 것을 프로그래머가 
 *   확신이 할 때 비로서 사용하는것이 바람직 하다. 
 *
 *   보통 object의 형변환 시에 자주 사용한다. 이것에 대한 자세한 사항은 
 *   "객체지향 프로그래밍" 강좌에서 또 언급될 것이다.
 */

public class Operator02
{
	public static void main(String[] args) 
	{
		/* OperatorTest_1.java 예제 "테스트 2"에서 결과는 2.0이 나왔다.
		 * 그 이유는 설명하였다. a, b 모두 int 형이고, 결과도 int 형이 나온다.
		 * 따라서, 2.5에서 소수점 이하 0.5가 짤린다. 그리고, 정수 2 는 암시적 형변환에 
		 * 의해서 2.0f 로 바뀌어 result 변수에 저장된다. */
		/*
		int a = 5;
		int b = 2;
		float result = a / b;
		 */

		/* 테스트 1 : 위의 예제가 정확한 값(2.5)이 나오도록 고쳐보자! */
		/*
		int a = 5;
		int b = 2;
		float result = (float)a / (float)b;
		System.out.println(result);
		 */
		/* 즉, 변수 a 와 b의 값을 float 형으로 바꾸고(type casting), 나누기(/) 연산을
		 * 수행하면, float과 float의 연산결과는 당연히 float 이 되므로 결과값은 2.5f가
		 * 된다. 따라서, 2.5f 값을 result변수에 할당하고 출력해 보면 2.5가 나올 것이다.
		 *
		 * >> 여기서 주의 할 것은, 형변환 했다고 a, b 변수의 데이터 형이 int에서 
		 * 영구적으로 float으로 바뀌는 것은 아니다. 다만 연산 수행시 값만 바뀔 뿐이다. 
		 */

		/* 테스트 2 : "테스트 1"에서는 a, b 변수 모두 type casting 했다. 
		 *			  이번에는 명시적 형변환과 암시적 형변환을 같이 이용해 보자! */
		/*
		int a = 5;
		int b = 2;
		float result = (float)a / b; //또는, float result =  a / (float)b;
		System.out.println(result);
		 */
		/* 변수 a의 값을 float 형으로 type casting 하고, 연산을 수행해 보니
		 * 쩝.. b는 int 형이라... float 과 int 는 연산을 수행할 수 없을 것이다.
		 * 여기서 바로, 변수 b에 대해 암시적 형변환이 일어난다. 즉, 내부적으로
		 * 변수 b의 값이 int 형에서 float 형으로 바뀌게 된다.
		 * 결과적으로 float 과 float의 연산이 되는 것이다.
		 * a는 그대로 두고, b의 값을 (float) 으로 type casting 해도 결과는 같다. */

		/* 테스트 3 : 큰 값을 작은 메모리에 넣어보자! */
		/*
		int a = 120;
		byte b = (byte)a;
		System.out.println(b);
		 */
		/* 위의 예제는 아무런 문제 없다. 컴파일도 OK!, 실행도 OK!, 출력 결과도 OK! 
		 * 그런데, 변수 a 값을 1200으로 바꾸어 컴파일 해보고 실행해 보자!
		 * 결과는 ? 헉~~~ -80 이 나올 것이다. 왜 그럴까?
		 * 값 1200을 4 바이트(int) 2진수로 표현해 보면 : 
		 *		0000 0000 0000 0000 0000 0100 1011 0000 
		 * 이것을 1 byte 메모리인 변수 b 에 강제로 꾸겨 넣으면, 앞의 3 byte가 짤린다.
		 *		0000 0000 0000 0000 0000 0100 이 짤리고
		 *		1011 0000 값이 변수 b 에 할당된다.
		 * 바이트에서는 2진수 1011 0000 값이 10진수 음수 -80이 된다.
		 * 한번, 1 바이트 값 80을 음수로 바꿔봐라!~
		 *		2진수 80 : 0101 0000
		 *		1의 보수 : 1010 1111
		 *		2의 보수( 1의 보수 값에 1을 더하면 된다.)
		 *				: 1011 0000
		 *
		 * 결론적으로, 무조건 형변환을 한다고 모든것이 해결되는 것은 아니다.
		 * 큰 값을 작은 메모리에 담기 위하여 형변환을 할 시에는 
		 * 그 값이 작은 값으로 바뀌더라도 값이 변경되지 않을 때만 형변환을 해야한다.
		 *
		 * 어떤 경우에는 고의적으로 형변환을 수행하는 경우도 있다.
		 * 예를 들면, 소수점을 제거하기 위하여 float 형을 int 형으로 형변환 
		 * 하는 경우가 있다.
		 */

		/* 테스트 4 : 컴퓨터에서의 음수의 표현
		 * 현재 우리가 쓰는 컴퓨터에서는 2의 보수 값을 음수로 사용한다. 
		 * 위에서 한번 해 봤을 것이다. 왜 이렇게 하는가?
		 * 컴퓨터는 뺄셈을 못한다. 단지 더할 뿐이다. 곱셈은 여러번 더하고, 
		 * 나눗셈은 여러번 빼고, 뺄셈은 더하고...
		 * 한번 예를 보자!
		 */
		/*
		int result = 10 - 3;
		System.out.println(result);
		 */
		/* 위의 예는 10 + (-3)으로 생각할 수있다.
		 * 10 의 2진수 표현(int 형) : 0000 0000 0000 0000 0000 0000 0000 1010
		 * -3 의 2진수 표현(int 형)
		 *		1) 먼저 3의 2진수 표현 : 0000 0000 0000 0000 0000 0000 0000 0011
		 *		2) 1의 보수 :		   1111 1111 1111 1111 1111 1111 1111 1100
		 *		3) 2의 보수 :		   1111 1111 1111 1111 1111 1111 1111 1101
		 *
		 * 10 과 -3을 더하면?
		 *		0000 0000 0000 0000 0000 0000 0000 1010 
		 *	+	1111 1111 1111 1111 1111 1111 1111 1101
		 * ---------------------------------------------
		 *      0000 0000 0000 0000 0000 0000 0000 0111 (즉, 10진수 7이 된다.)
		 *
		 */  
	}
}
